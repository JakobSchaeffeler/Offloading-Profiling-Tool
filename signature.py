import sys
import os
import subprocess
from shutil import which
import argparse
import csv

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import json
import re
import math

display_baseline = False

def main():
    parser = argparse.ArgumentParser(description = "Tool for automatic generation of signature plots. Uses the csv files generated by create_profiles.py")
    parser.add_argument("inputfile", help="This is the base implementation, all other plots are relative to this file")
    parser.add_argument("inputfiles", nargs="+")
    parser.add_argument("--display-baseline", action="store_true", help="If enabled the baseline will be displayed in a seperate plot (all ones)")
    parser.add_argument("--name", required = True, default = "")
    args = parser.parse_args()
    base_file = args.inputfile
    file_list = args.inputfiles
    nargs = len(file_list)

    #check how many plots exist for plotting in grids
    xdim = 1
    if args.display_baseline:
        nargs += 1
    if nargs > 4:
        xdim = int(nargs / 4) if nargs % 4 == 0 else int(nargs / 2)

    ydim = int(math.ceil(nargs / float(xdim)))



    base_df = pd.read_csv(base_file)
    base_dict = base_df.set_index("Name")['Value'].to_dict()

    # get rid of unnecessary metrics
    if "Total" in base_dict:
        base_dict.pop("Total")
    if "Sync Total" in base_dict:
        base_dict.pop("Sync Total")
    if "Calls" in base_dict:
        base_dict.pop("Calls")


    threads_dict = {}
    base_name = base_dict.pop("Model")
    threads_base = base_dict.pop("#Threads")
    teams_base = base_dict.pop("#Teams")

    base_dict = {k: float(v) for k, v in base_dict.items()}
    #keys = ["Kernel Speedup", "Avg Kernel + Sync Speedup", "Min Kernel + Sync Speedup", "Max Kernel + Sync Speedup", "HtoD Size", "HtoD Transfer Speedup", "DtoH Size", "DtoH Transfer Speedup"]
    keys = ["Kernel Speedup", "Kernel + Sync Speedup", "HtoD Size", "HtoD Transfer Speedup", "DtoH Size", "DtoH Transfer Speedup"]

    dtoh = True
    htod = True

    #check if DtoH Copies in base implementation, if not remove metrics
    if base_dict["DtoH Size"] == 0:
        base_dict.pop("DtoH Time")
        keys.remove("DtoH Transfer Speedup")
        keys.remove("DtoH Size")
        dtoh = False
        base_dict.pop("DtoH Size")

    #check if DtoH Copies in base implementation, if not remove metrics
    if base_dict["HtoD Size"] == 0:
        base_dict.pop("HtoD Time")
        keys.remove("HtoD Transfer Speedup")
        htod = False
        keys.remove("HtoD Size")
        base_dict.pop("HtoD Size")

    #palette_list = sns.color_palette("colorblind").as_hex()
    #palette_list.append("#a8b6cc")
    color_palette = sns.color_palette("colorblind", n_colors=len(keys))
 
    fig, axs = plt.subplots(2,2)

    # get base min/max values for Kernel Speedups
    base_min = base_dict.pop("Min")
    base_max = base_dict.pop("Max")
    base_sync_min = base_dict.pop("Sync Min")
    base_sync_max = base_dict.pop("Sync Max")
    base_array = np.array(list(base_dict.values()))

    df = pd.DataFrame({"Name": keys, "": base_array/base_array})
    #create and delete plot to get labels
    sns.barplot(x='Name', y='', hue='Name', legend=True, data=df, ax=axs[0,0],  palette=color_palette)
    handles, labels = axs[0,0].get_legend_handles_labels()
    plt.close()

    #create subplots
    fig, axs = plt.subplots(xdim, ydim, layout='constrained')

    #get name of base implementation
    full_path_dir = os.path.split(os.path.abspath(base_file))[0]
    sub_name = os.path.split(os.path.abspath(full_path_dir))[-1]
    sub_name = sub_name.replace("results_", "")
    sub_name += " " + base_name
    sub_name = sub_name.replace("_", " ")
    baseline_name = sub_name

    # store threads/team numbers in dict to print later
    threads_dict[baseline_name] = [threads_base,teams_base]


    # only plot baseline if wanted (all 1s)
    if args.display_baseline:
        sns.barplot(x='Name', y='',hue='Name', legend=False, data=df, ax=axs[0] if xdim == 1 else axs[0,0], palette=color_palette)
        axs[0].set_xticklabels([]) if xdim == 1 else axs[0,0].set_xticklabels([])
        full_path_dir = os.path.split(os.path.abspath(base_file))[0]
        sub_name = os.path.split(os.path.abspath(full_path_dir))[-1]
        sub_name = sub_name.replace("results_", "")

        sub_name += " " + base_name
        sub_name = sub_name.replace("_", " ")
        axs[0].set_title(sub_name, fontsize=10) if xdim == 1 else axs[0,0].set_title(sub_name, fontsize=10)
        axs[0].set(xlabel=None) if xdim == 1 else axs[0,0].set_title(sub_name, fontsize=10)

    maxi = 1

    # plotting of relative implementations
    for i in range(len(file_list)):
        rel_file = file_list[i]
        rel_df = pd.read_csv(rel_file)
        rel_dict = rel_df.set_index("Name")['Value'].to_dict()

        rel_name = rel_dict.pop("Model")
        threads_rel = rel_dict.pop("#Threads")
        teams_rel = rel_dict.pop("#Teams")

        # get min/max kernel metrics
        min_rel = float(rel_dict.pop("Min"))
        max_rel = float(rel_dict.pop("Max"))
        min_rel_sync = float(rel_dict.pop("Sync Min"))
        max_rel_sync = float(rel_dict.pop("Sync Max"))

        # delete unwanted metrics
        if "Total" in rel_dict:
            rel_dict.pop("Total")
        if "Sync Total" in rel_dict:
            rel_dict.pop("Sync Total")
        if "Calls" in rel_dict:
            rel_dict.pop("Calls")

        rel_dict = {k: float(v) for k, v in rel_dict.items()}

        # if copies are present in rel but not in base => Warning
        if not dtoh:
            t = rel_dict.pop("DtoH Time")
            s = rel_dict.pop("DtoH Size")
            if t > 0 or s > 0:
                print("Warning: DtoH Copies are not present in base implementation, but in " + rel_file)

        if not htod:
            t = rel_dict.pop("HtoD Time")
            s = rel_dict.pop("HtoD Size")
            if t > 0 or s > 0:
                print("Warning: HtoD Copies are not present in base implementation, but in " + rel_file)

        rel_array = np.array(list(rel_dict.values()))

        # compute speedups
        min_speedup = base_array[0]/min_rel
        max_speedup = base_array[0]/max_rel
        speedup = base_array[0]/rel_array[0]
        min_speedup_sync = base_array[1]/min_rel_sync
        max_speedup_sync = base_array[1]/max_rel_sync
        speedup_sync = base_array[1]/rel_array[1]

        curr_max = np.max(base_array/rel_array)

        # keep track of max speedup for nicer plotting
        if curr_max > maxi:
            maxi = curr_max

        df = pd.DataFrame({"Name": keys, "": base_array/rel_array})
        ax_curr = axs if xdim == 1 and ydim == 1 else axs[i+1 if args.display_baseline else i] if xdim == 1 else axs[int((i+1 if args.display_baseline else i)/ydim), (i+1 if args.display_baseline else i) % ydim]
        sns.barplot(x='Name', y='', hue='Name', legend=False, data=df, ax=ax_curr,  palette=color_palette)

        # plotting of min/max kernel Speedup
        p = ax_curr.patches[0]
        x = p.get_x()
        w = p.get_width()
        h = p.get_height()
        ax_curr.vlines(x+w/2, min_speedup, max_speedup, color='k')

        # plotting of min/max Kernel + Sync Speedup
        p = ax_curr.patches[1]
        x = p.get_x()
        w = p.get_width()
        h = p.get_height()
        ax_curr.vlines(x+w/2, min_speedup_sync, max_speedup_sync, color='k')

        full_path_dir = os.path.split(os.path.abspath(rel_file))[0]
        sub_name = os.path.split(os.path.abspath(full_path_dir))[-1]
        sub_name = sub_name.replace("results_", "")

        sub_name += " " + rel_name
        sub_name = sub_name.replace("_", " ")
        threads_dict[sub_name] = [threads_rel,teams_rel]

        #offset = i+1 if args.display_baseline else i

        # set subtitle name
        ax_curr.set_title(sub_name, fontsize=10) #if xdim == 1 else axs[int(offset/ydim), (i+1 if args.display_baseline else i) % ydim].set_title(sub_name, fontsize=10)

        # set empty xaxis tick labels
        ax_curr.set_xticklabels([]) #if xdim == 1 else axs[int(offset/ydim), offset % ydim].set_xticklabels([])

        # get rid of x label
        ax_curr.set(xlabel=None) #if xdim == 1 else axs[int(offset/ydim), offset % ydim].set(xlabel=None)

    # add grid and same y limit to each plot
    if nargs > 1:
        for i in range(0,nargs):
            axs[i].set_ylim([0, maxi + 0.1*maxi]) if xdim == 1 else axs[int((i)/ydim), (i) % ydim].set_ylim([0, maxi + 0.1*maxi])
            axs[i].grid(axis = 'y', linestyle = "dashed", alpha = 0.5) if  xdim == 1 else axs[int((i)/ydim), (i) % ydim].grid(axis = 'y', linestyle = "dashed", alpha = 0.5)
            for line in axs[i].get_ygridlines():
                if line.get_data()[1][0] == 1:
                    line.set(alpha=1, color="black", linewidth=line.get_linewidth()+0.25)

    else:
        axs.grid(axis = 'y', linestyle = "dashed", alpha = 0.5)
        for line in axs.get_ygridlines():
            if line.get_data()[1][0] == 1:
                line.set(alpha=1, color="black",linewidth=line.get_linewidth()+0.25)
    # print threads/teams used by each implementation
    for name in threads_dict.keys():
        thr = threads_dict[name]
        print(name + ": " + thr[0] + " Threads, " + thr[1] + " Teams")



    fig.set_figwidth(3*(ydim))
    fig.set_figheight(xdim * 4.8)

    fig.legend(handles, labels, loc='outside lower center',  ncol = 2 if xdim < 4 else 4)
    fig.suptitle("Signature plot for " + args.name + " relative to " + baseline_name)
    print("Saving to " + "signature_" + args.name + ".pdf")
    plt.savefig("signature_" + args.name + ".pdf", bbox_inches="tight")


if  __name__ == "__main__":
    main()

